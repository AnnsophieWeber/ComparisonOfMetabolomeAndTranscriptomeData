###########################################################################################################################################################################
# SUBSEQUENT DIFFERENTIAL GENE EXPRESSION ANALYSIS
# Script to analyse the differential gene expression for selected genes further.
# To do the analysis, you need the .rds file of the ImpulseDE2 object generated with the "differential_gene_expression_analysis.R" script. 
# This script will produce: 
#       - time series plots of selected genes
#       - two heatmaps (raw normalised counts and model fit counts) with each a file of the z-scores for the selected genes
#       - a file containing normalised counts for selected genes
#       - a file containing normalised counts, their means and standard deviation for selected genes
#       - a file containing means and standard deviation for selected genes
#       - a file containing means for selected genes
###########################################################################################################################################################################
      start_time <- Sys.time()

# 1)  SET YOU WORKING DIRECTORY. This is where your input file is located and the results will be stored.
#     Click in the menubar on the tab "Session" > "Set Working Directory" > "Choose Directory..."
#     Then choose the directory where your input file (the one with the means) is located and the results will be stored.



# 2)  READ/IMPORT your generated objectImpulseDE2 object generated by the "differential_gene_expression_analysis.R" into RStudio.

      objectImpulseDE2 <- readRDS("your_objectImpulseDE2.rds")

      
      
# 3)  SPECIFY your data information:
      
      # How should the timepoints be called? 
      TimeCateg <- c("Timepoint1", "Timepoint2", "Timepoint3", "Timepoint4", "Timepoint5")
      

      
# 4)  DECIDE of which selected genes you want time series plots as results.
#     Attention: Genes can only be plotted, if they show non-zero counts for all timepoints. If a plot for a selected gene is missing in the results,
#     it shows zero counts at all timepoints and was therefore excluded from the analysis.

      selected_genes <- c("gene_1",
                          "gene_2",
                          "gene_3",
                          "gene_5",
                          "gene_6")
      
#     If some (or all) of the selected genes are differentially expressed, a small heatmap will be generated to visualise the differential expression.
#     Genes that don't show differential expression will not be included in the heatmap.

      

# 5) DEFINE font sizes for row and column titles, names, the legend title, legend lables and the size of the legend bar in the heatmap.       
#    If you don't want to use these options and use the default, just write NULL instead of a number for the variable you don't
#    want to use. 
      
      # Set the font sizes
      # Recommended: numbers between 10 and 30
      heatmap_row_title_font_size <- NULL
      heatmap_row_column_name_font_size <- NULL
      legend_title_font_size <- NULL
      legend_label_font_size <- NULL
      
      # Set the size of the legend bar (in points)
      # Recommended: a number between 100 and 200
      legend_height <- NULL
      
      
      
# 6)  DECIDE what should be shown in the plot. Write TRUE if the line/points should be shown, write FALSE if it should not be shown. 
#     You can also decide on a colour for the corresponding lines/points.
#     Colours can be chosen from http://www.stat.columbia.edu/~tzheng/files/Rcolor.pdf 
      
      # Graph of the fitted model calculated by ImpulseDE2
      show_fitted_model_in_plot <- TRUE
      colour_fitted_model <- "midnightblue"
      
      # Graph of the means calculated from the normalised counts
      show_normalised_count_means <- TRUE
      colour_normalised_count_means <- "cornflowerblue"
      
      # Data points of normalized counts
      show_normalised_counts <- TRUE
      colour_normalised_counts <- "slategray2"
      
      # Set the font size for the x and y ticks, names and the legend labels in the time series plot.
      # If you don't want to use these options and use the default, just write NULL instead of a number for the variable you don't
      # want to use.
      # Recommended: numbers between 10 and 20
      time_series_plot_axis_name_label_size <- NULL
      time_series_plot_legend_label_size <- NULL
      
      # DECIDE whether the timepoints should be shown as numbers or as names (TimeCateg) on the x axis of the time series plot.
      # If the names should be shown, write TRUE, if the numbers should be shown, write FALSE.
      
      show_TimeCateg_on_x_axis <- TRUE
      
      
      
# 7)  NAME your output files/plots. The name should be as SHORT as possible. 
#     All relevant information about the results will be put in the file name automatically. 
      
      output_name <- "your_output_name"  # Type here the desired name of the output
      
      

# 8)  LET THE SCRIPT DO THE REST  
#     Highlight all code and press Ctrl + Enter.
#     Plots and files will be saved automatically.
      
      
      
      
      
      
###########################################################################################################################################################################  
###########################################################################################################################################################################
# DON'T CHANGE ANYTHING IN HERE
      
      
# CREATE A NEW DIRECTORY where the results will be stored.
      dir_name <- paste(Sys.Date(), "_", output_name,  "_results_subsequent_de", sep = "")
      ifelse(!dir.exists(dir_name), dir.create(dir_name), FALSE)
      results_dir <- file.path(getwd(), dir_name)
      Sys.chmod(results_dir, mode = "0777", use_umask = TRUE)
      setwd(results_dir)
      
      
      library(ImpulseDE2)
      dfAnnot <- get_dfAnnotationProc(obj=objectImpulseDE2)
      Time <- sort(unique(dfAnnot$Time), decreasing = FALSE)      
      Reps <- rep(Time, each = nrow(dfAnnot)/length(Time))
      
      
# WRITE default values for plotting options  
      # Time series plot
      if (is.null(time_series_plot_axis_name_label_size)) {time_series_plot_axis_name_label_size <- 12}
      if (is.null(time_series_plot_legend_label_size)) {time_series_plot_legend_label_size <- 10}
      
      # Heatmap
      if (is.null(heatmap_row_title_font_size)) {heatmap_row_column_title_font_size <- 30}
      if (is.null(heatmap_row_column_name_font_size)) {heatmap_row_column_name_font_size <- 20}
      if (is.null(legend_title_font_size)) {legend_title_font_size <- 20}
      if (is.null(legend_label_font_size)) {legend_label_font_size <- 15}
      if (is.null(legend_height)) {legend_height <- 150}
      
      
      library(xlsx)
      
###################################################################################################################
# PLOT TIME SERIES OF SELECTED GENES ##############################################################################
###################################################################################################################
      
      library(dplyr)
      library(ggplot2)
      
      if (!is.null(selected_genes)){
        
          # sort out selected genes, that have all 0 counts 
          selected_genes_copy <- selected_genes[which(is.element(selected_genes, rownames(objectImpulseDE2@matCountDataProc)))]
          
          if (length(selected_genes_copy) == 0) {
              sink(paste(output_name, "_selected_genes_time_series_plots.txt", sep = ""))
              print("None of your selected genes shows any counts, all are zero, so no plots could be generated.")
              print("Your selected genes were:")
              print(selected_genes)
              sink()
            
          } else {
            
              for (i in 1:length(selected_genes_copy)) {
                
                  selected_expression <- plotGenes(
                    vecGeneIDs = selected_genes_copy[i],
                    objectImpulseDE2 = objectImpulseDE2,
                    boolCaseCtrl = FALSE,
                    boolMultiplePlotsPerPage = TRUE,
                    boolSimplePlot = TRUE)
                  
                  # create own plot with fitted curve and mean
                  # get fit data for fit curve
                  fitted_curve <- selected_expression[[1]]$plot_env$dfFit[, 1:2]
                  colnames(fitted_curve) <- c("time", "fitCurve")
                  
                  # get normCounts from replicates for data points
                  normCounts <- selected_expression[[1]]$plot_env$dfRaw
                  normCounts <- normCounts[, c("time", "normCounts")]
                  
                  # calculate means of normCounts for mean curve
                  means <- aggregate(selected_expression[[1]]$plot_env$dfRaw$normCounts, list(selected_expression[[1]]$plot_env$dfRaw$time), mean)
                  colnames(means) <- c("time", "normCountMeans")
                  
                  # create full joined data frame with all values to plot all in the same plot and additionally order it by time
                  big_df <- full_join(fitted_curve, normCounts, by = "time")
                  big_df <- full_join(big_df, means, by = "time")
                  big_df <- big_df[with(big_df, order(time)), ]
                  
                  tempplot <- ggplot(data = NULL, aes(x = Time)) +
                    labs(x = "Timepoint", y = "Transcript counts", title = selected_genes_copy[i]) +
                    theme_minimal()+
                    scale_color_manual(values=c(colour_fitted_model, colour_normalised_count_means, colour_normalised_counts))
                    
                  if (show_TimeCateg_on_x_axis) { 
                    tempplot <- tempplot + scale_x_continuous(breaks=Time,labels=TimeCateg)
                    tempplot <- tempplot + theme(axis.text.x = element_text(angle=45, hjust = 1), plot.title = element_text(hjust = 0.5), text = element_text(size = time_series_plot_axis_name_label_size), legend.title=element_blank(), legend.text =element_text(size = time_series_plot_legend_label_size))
                  } else {
                    tempplot <- tempplot + scale_x_continuous(labels = Time, breaks = Time)
                    tempplot <- tempplot + theme(plot.title = element_text(hjust = 0.5), text = element_text(size = time_series_plot_axis_name_label_size), legend.title=element_blank(), legend.text =element_text(size = time_series_plot_legend_label_size))
                  }
                
                  if (show_fitted_model_in_plot) {
                      tempplot <- tempplot + geom_line(data = na.omit(big_df[, 1:2]), aes(x=time, y = fitCurve, colour = "ImpulseDE2 fitted model"))}
                  
                  if (show_normalised_count_means) {
                      tempplot <- tempplot + geom_line(data = unique(na.omit(big_df[, c(1, 4)])), aes(y = normCountMeans, colour = "Normalised count means"))}
                  
                  if (show_normalised_counts) {
                      tempplot <- tempplot + geom_point(data = na.omit(big_df[, c(1, 3)]), aes(x=Reps ,y = normCounts, colour = "Normalised counts"))}
                
                  ggsave(tempplot, device = "png", file=paste(output_name, "_selected_", selected_genes_copy[i] , ".png", sep = ""), width = 200, height = 200, units = "mm", dpi = 600)
                
              }
          }
      }
      
      
      
      
      
      
      
####################################################################################################################
# CREATE HEATMAP ON SELECTED DIFFERENTIAL EXPRESSED GENES ##########################################################
####################################################################################################################
      
      library(ComplexHeatmap)
      lsHeatmaps <- plotHeatmap(
        objectImpulseDE2       = objectImpulseDE2,
        strCondition           = "case",
        boolIdentifyTransients = TRUE,
        scaQThres              = 0.01)
      
      
      # CREATE DATA FRAME with raw z-score values
      raw_z_scores <- lsHeatmaps$complexHeatmapRaw@matrix
      raw_z_scores <- data.frame(raw_z_scores)
      colnames(raw_z_scores) <- c(paste("z.score.stage.", Time, sep = ""))
      
      
      # ADD the differential expression status and the gene names to the data frame
      raw_z_scores["differential.expression"] <- lsHeatmaps$complexHeatmapRaw@matrix_param$row_split
      raw_z_scores["gene"] <- c(lsHeatmaps$lsvecGeneGroups$transition_up, lsHeatmaps$lsvecGeneGroups$transition_down, lsHeatmaps$lsvecGeneGroups$transient_up, lsHeatmaps$lsvecGeneGroups$transient_down)
      
      # RAW Z-SCORES #
      
      # set rownames to the z-score data frame, so that gene names won't be lost in the following data matrix
      rownames(raw_z_scores) <- raw_z_scores$gene
      
      # create data matrix with selected genes for heatmap 
      selected_genes_dm <- data.frame(raw_z_scores[selected_genes, 1:length(Time)])
      selected_genes_dm <- as.matrix(selected_genes_dm)
      
      # maybe not all selected genes are differentially expressed, so there will be NA's in the matrix
      # NA's are not allowed for heatmap plotting, so they have to be removed
      selected_genes_dm <- na.omit(selected_genes_dm)
      
      # change colnames, because they are plotted in the heatmap
      colnames(selected_genes_dm) <- Time
      
      # get the differential expression status for the genes (splits heatmap by groups: *up, *down, up or down)
      selected_de <- raw_z_scores[selected_genes, length(Time)+1]
      
      # remove NA's as well for not differential expressed genes
      selected_de <- na.omit(selected_de)
      
      # plot the heatmap with ComplexHeatmap package, the settings are the same as for the lsHeatmaps, so they look alike
      if (nrow(selected_genes_dm > 0)) {
        
        heatmap_selected <- Heatmap(selected_genes_dm, 
                                    gap = unit(5, "mm"), 
                                    cluster_rows = FALSE, 
                                    cluster_columns = FALSE, 
                                    split = selected_de,  
                                    heatmap_legend_param = list(title = "z-score", title_gp =gpar(fontsize = legend_title_font_size), labels_gp=gpar(fontsize = legend_label_font_size), legend_height=unit(legend_height, "points"), just = c("right", "top")), 
                                    row_names_gp = gpar(fontsize = heatmap_row_column_name_font_size), 
                                    row_title_gp = gpar(fontsize = heatmap_row_title_font_size),
                                    column_names_gp = gpar(fontsize = heatmap_row_column_name_font_size),
                                    column_names_rot = 90)
        
        # DRAW HEATMAP with normalised raw data
        png(paste(output_name, "_selected_genes_heatmap_raw_data.png"), width = 4800, height = 4800, res = 600)
        draw(heatmap_selected)
        dev.off()
        
        colnames(selected_genes_dm) <- TimeCateg
        
        write.xlsx(selected_genes_dm, paste(output_name, "_selected_genes_raw_heatmap.xlsx", sep = ""))
        
      } else {
        
        sink(paste(output_name, "selected_genes_heatmaps.txt", sep = ""))
        print("None of your selected genes shows differential expression, so no heatmaps could be generated.")
        print("Your selected genes were:")
        print(selected_genes)
        sink()
        
      }
      
      
      
      # CREATE DATA FRAME with fitted z-score values
      fit_z_scores <- lsHeatmaps$complexHeatmapFit@matrix
      fit_z_scores <- data.frame(fit_z_scores)
      colnames(fit_z_scores) <- c(paste("z.score.stage.", Time, sep = ""))
      
      
      # ADD the differential expression status and the gene names to the data frame
      fit_z_scores["differential.expression"] <- lsHeatmaps$complexHeatmapFit@matrix_param$row_split
      fit_z_scores["gene"] <- c(lsHeatmaps$lsvecGeneGroups$transition_up, lsHeatmaps$lsvecGeneGroups$transition_down, lsHeatmaps$lsvecGeneGroups$transient_up, lsHeatmaps$lsvecGeneGroups$transient_down)
      
      # FITTED Z-SCORES #
      
      # set rownames to the z-score data frame, so that gene names won't be lost in the following data matrix
      rownames(fit_z_scores) <- fit_z_scores$gene
      
      # create data matrix with selected genes for heatmap 
      selected_genes_dm <- data.frame(fit_z_scores[selected_genes, 1:length(Time)])
      selected_genes_dm <- as.matrix(selected_genes_dm)
      
      # maybe not all selected genes are differentially expressed, so there will be NA's in the matrix
      # NA's are not allowed for heatmap plotting, so they have to be removed
      selected_genes_dm <- na.omit(selected_genes_dm)
      
      # change colnames, because they are plotted in the heatmap
      colnames(selected_genes_dm) <- Time
      
      # get the differential expression status for the genes (splits heatmap by groups: *up, *down, up or down)
      selected_de <- fit_z_scores[selected_genes, length(Time)+1]
      
      # remove NA's as well for not differential expressed genes
      selected_de <- na.omit(selected_de)
      
      # plot the heatmap with ComplexHeatmap package, the settings are the same as for the lsHeatmaps, so they look alike
      
      if (nrow(selected_genes_dm > 0)) {
        
        heatmap_selected <- Heatmap(selected_genes_dm, gap = unit(5, "mm"), 
                                    cluster_rows = FALSE, 
                                    cluster_columns = FALSE, 
                                    split = selected_de,  
                                    heatmap_legend_param = list(title = "z-score", title_gp =gpar(fontsize = legend_title_font_size), labels_gp=gpar(fontsize = legend_label_font_size), legend_height=unit(legend_height, "points")), 
                                    row_names_gp = gpar(fontsize = heatmap_row_column_name_font_size), 
                                    row_title_gp = gpar(fontsize = heatmap_row_title_font_size),
                                    column_names_gp = gpar(fontsize = heatmap_row_column_name_font_size),
                                    column_names_rot = 90)
        
        # Draw HEATMAP with normalised fit data
        png(paste(output_name, "_selected_genes_heatmap_fit_data.png"), width = 4800, height = 4800, res = 600)
        draw(heatmap_selected)
        dev.off()
        
        colnames(selected_genes_dm) <- TimeCateg
        
        write.xlsx(selected_genes_dm, paste(output_name, "_selected_genes_fitted_heatmap.xlsx", sep = ""))
        
      }
      
      
      
####################################################################################################################
# CREATE FILES WITH NORMALISED COUNTS, MEANS AND STANDARD DEVIATIONS (SD) ##########################################
####################################################################################################################
      
      # processed data frame without missing values e.g.
      matCountDataProc <- get_matCountDataProc(objectImpulseDE2) 
      
      # size factors for calculating size factor scaled and normalized counts
      vecSizeFactors <- get_vecSizeFactors(objectImpulseDE2) 
      
      
      
      # create data frame with normalized counts:
      # divide counts by scale size factor
      norm_counts <- sweep(matCountDataProc, 2, vecSizeFactors, `/`)
      norm_counts <- data.frame(norm_counts)
      norm_counts <- norm_counts[selected_genes,]
      
      number_of_timepoints <- length(Time)
      number_of_replicates <- ncol(norm_counts)/number_of_timepoints
      
      colnames(norm_counts) <- paste(rep(TimeCateg, times=number_of_replicates), rep(1:number_of_replicates, each=number_of_timepoints),sep = ".")

      
      # save file with norm counts
      write.xlsx(norm_counts, paste(output_name, "_selected_genes_normalised_counts.xlsx", sep = ""))
      
      
      cols <- as.numeric()
      for (j in 1:number_of_timepoints) {
        for (i in 0:(number_of_replicates-1)) {
          cols <- append(cols, i*number_of_timepoints+j)
        }  
      }
      
      counts_means_sd <- data.frame(matrix(nrow = nrow(norm_counts)))
      means <- data.frame(matrix(nrow = nrow(norm_counts)))
      means_sd <- data.frame(matrix(nrow = nrow(norm_counts)))
      
      
      for (i in 1:number_of_timepoints){
        # get columns
        temp <- split(cols, sort(cols%%number_of_timepoints))[[i]]
        
        #create temporary data frame for each timepoint
        temp_df <- norm_counts[,temp]
        temp_df$mean <- apply(temp_df, 1, mean, na.rm=TRUE)
        temp_df$sd <- apply(temp_df[,1:number_of_replicates], 1, sd, na.rm=TRUE)
        
        # create big data frames that will be saved
        counts_means_sd <- cbind.data.frame(counts_means_sd, temp_df)
        
        # create a data frame with just the means
        means <- cbind.data.frame(means, temp_df$mean)
        row.names(means) <- row.names(norm_counts)
        
        # create a data frame with the means and the standard deviations
        means_sd <- cbind.data.frame(means_sd, temp_df$mean, temp_df$sd)
        row.names(means_sd) <- row.names(norm_counts)
      }
      
      # save the created data frames
      counts_means_sd <- counts_means_sd[,-1]
      colnames(counts_means_sd) <- paste(rep(TimeCateg, each=number_of_replicates+2), rep(c(1:number_of_replicates, "mean", "sd"), number_of_replicates+2), sep = ".")
      write.xlsx(counts_means_sd, paste(output_name, "_selected_genes_normalised_counts_means_sd.xlsx", sep = ""))
      
      means <- means[,-1]
      colnames(means) <- TimeCateg
      write.xlsx(means, paste(output_name, "_selected_genes_normalised_means.xlsx", sep = ""))
      
      means_sd <- means_sd[,-1]
      colnames(means_sd) <- paste(rep(TimeCateg, each=2),rep(c("mean", "sd"), times = number_of_timepoints) , sep = ".")
      write.xlsx(means_sd, paste(output_name, "_selected_genes_normalised_means_sd.xlsx", sep = ""))
      
      end_time <- Sys.time()
      
      
      
      
      
      paste("Total time consumed for the analysis:", round(end_time - start_time, 2), attr((end_time - start_time), "unit"))